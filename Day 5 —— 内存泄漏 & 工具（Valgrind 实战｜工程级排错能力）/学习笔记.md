## 一、Day 5 学习目标

> 从“知道内存泄漏”到：
>
> **能系统性定位、解释、修复内存泄漏问题。**

在真实 C++ 后端系统中：

* 内存泄漏 ≠ 立即崩溃
* 内存泄漏 = **长期运行后 OOM / 性能雪崩**

👉 排查能力是后端工程师的硬实力。

---

## 二、什么是内存泄漏（工程定义）

> **程序丢失了对一块已分配内存的控制权，且该内存无法再释放。**

本质：

* 内存仍然存在
* 但你已经“找不到它了”

---

## 三、常见内存泄漏场景（必须熟到条件反射）

### 1️⃣ new 了但忘记 delete

```cpp
void foo() {
    int* p = new int(10);
}
```

问题：

* 函数结束
* 指针 p 消失
* 内存永久泄漏

---

### 2️⃣ 多 return / 异常路径忘记释放

```cpp
int* p = new int(10);
if (error) return -1;   // ❌ 泄漏
```

工程中非常常见。

---

### 3️⃣ 覆盖指针（指针重指向）

```cpp
int* p = new int(10);
p = new int(20);  // ❌ 第一块内存泄漏
```

---

### 4️⃣ 容器中存裸指针

```cpp
vector<User*> users;
users.push_back(new User());
```

如果没有统一释放逻辑：

* 100% 泄漏

---

### 5️⃣ 析构函数缺失（面试高频）

```cpp
class A {
public:
    int* p = new int(10);
};
```

问题：

* delete A 对象时
* p 永远不会被释放

---

## 四、为什么 C++ 容易内存泄漏？

原因不是“语言差”，而是：

* 手动资源管理
* 多路径控制流
* 异常机制

---

## 五、Valgrind 是什么？

> **运行期内存行为分析工具**

它能发现：

* 内存泄漏
* 非法访问
* 重复释放

📌 不需要改代码，只需重新编译。

---

## 六、Valgrind 基本使用（必须会）

### 1️⃣ 编译（带调试信息）

```bash
g++ -g leak.cpp -o leak
```

---

### 2️⃣ 运行 valgrind

```bash
valgrind --leak-check=full ./leak
```

---

### 3️⃣ 关键输出解读

```text
==1234== definitely lost: 16 bytes in 1 blocks
```

含义：

* 明确泄漏
* 且无法再访问

---

