## 一、基础理解题

### 题 1：为什么 `vector` 的随机访问是 O(1)？

#### 参考答案

因为 `vector` 采用 **连续内存存储**，可以通过：

```text
address = begin + index * sizeof(T)
```

直接定位元素，无需遍历。

---

### 题 2：`size()` 和 `capacity()` 的区别是什么？

#### 参考答案

* `size()`：当前已构造的元素数量
* `capacity()`：已分配但可能未使用的内存容量

`capacity() >= size()` 永远成立。

---

## 二、扩容机制题

### 题 3：以下代码中，`push_back` 一共发生了几次扩容？

```cpp
vector<int> v;
for (int i = 0; i < 100; ++i)
    v.push_back(i);
```

#### 参考答案

* 扩容次数与 **实现有关**
* 通常为 `O(log N)` 次
* GCC / Clang 下一般约 7 次左右

> 标准不保证具体次数，只保证复杂度。

---

### 题 4：`reserve(100)` 后再插入 100 个元素，时间复杂度？

#### 参考答案

* 不发生 reallocation
* 每次 `push_back` 为 **严格 O(1)**

---

## 三、迭代器失效判断题

### 题 5：判断下列代码是否安全

```cpp
auto it = v.begin();
v.push_back(x);
use(*it);
```

#### 参考答案

* **不一定安全**
* 若 `push_back` 触发扩容 → UB
* 若未扩容 → 安全

结论：**不能这样写**。

---

### 题 6：哪些操作一定导致全部迭代器失效？

A. `push_back`
B. `reserve`
C. `clear`
D. `erase`

#### 参考答案

* **B（可能）**：若发生扩容
* **C（一定）**

---

## 四、工程设计题

### 题 7：为什么 `vector` 不适合频繁在头部插入？

#### 参考答案

* 连续内存结构
* 头插需要整体后移元素
* 时间复杂度 `O(n)`
* 频繁移动破坏性能

---

### 题 8：如何设计代码避免迭代器失效问题？

#### 参考答案

1. 提前 `reserve`
2. 不缓存迭代器
3. 修改容器后重新获取迭代器
4. 使用返回值（如 `erase`）

---

## 五、进阶思考题（面试级）

### 题 9：为什么 `vector` 比 `list` cache 友好？

#### 参考答案

* 连续内存
* 顺序访问命中 cache line
* 减少 cache miss
* 实际性能往往优于 `list`

---

### 题 10：什么时候不该用 `vector`？

#### 参考答案

* 需要稳定迭代器
* 频繁中间插入/删除
* 超大对象频繁扩容搬迁

---

✅ **本题集覆盖：原理理解、UB 判断、工程设计与面试思维**
