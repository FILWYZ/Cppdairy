通过一个**最小工程 → 拆分库的工程**，理解 CMake 的真实用法。

---

## 示例一：最小可执行程序

### 目录结构

```text
hello/
├── CMakeLists.txt
└── main.cpp
```

### main.cpp

```cpp
#include <iostream>
int main() {
    std::cout << "Hello CMake" << std::endl;
}
```

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(hello)
add_executable(hello main.cpp)
```

---

## 示例二：可执行文件 + 静态库

### 目录结构

```text
project/
├── CMakeLists.txt
├── app/
│   └── main.cpp
└── lib/
    ├── mylib.h
    └── mylib.cpp
```

---

### lib/CMakeLists.txt

```cmake
add_library(mylib mylib.cpp)
target_include_directories(mylib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

---

### 顶层 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(demo)

add_subdirectory(lib)
add_subdirectory(app)
```

---

### app/CMakeLists.txt

```cmake
add_executable(app main.cpp)
target_link_libraries(app PRIVATE mylib)
```

---

## 示例三：错误写法（反例）

```cmake
include_directories(lib)
add_executable(app main.cpp lib/mylib.cpp)
```

问题：

* 破坏模块边界
* 无法复用

---

## 示例四：正确的 target 思维

* 库负责暴露接口
* 可执行程序只声明依赖

---

## 实战总结

* 一个 target = 一个模块
* CMake 代码反映工程结构
