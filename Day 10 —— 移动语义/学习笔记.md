### 一、为什么需要“移动语义”？

在 Day9 你已经知道：

* 深拷贝是 **安全的**
* 但深拷贝通常是 **昂贵的**（new / delete / 内存复制）

思考一个场景：

```cpp
vector<A> v;
v.push_back(A(10));
```

这里的 `A(10)`：

* 是一个 **临时对象**
* 马上就要被销毁

❓问题：

> 我们真的有必要 **深拷贝一份资源** 吗？

👉 **移动语义就是为了解决这个问题而生的**。

---

### 二、左值 / 右值（只讲够用版）

* **左值**：有名字、能取地址、能长期存在
* **右值**：临时对象、即将销毁

```cpp
A a;        // a 是左值
A(10);     // 右值（临时对象）
```

---

### 三、右值引用（&&）

```cpp
A&& r = A(10);
```

含义：

> “我明确知道你是个 **马上要死的对象**”

👉 编译器因此 **允许我们偷你的资源**。

---

### 四、移动构造函数（Move Constructor）

#### 1️⃣ 定义形式

```cpp
class A {
public:
    A(A&& other);
};
```

注意：

* 参数是 **右值引用**
* 说明传进来的是“临时对象”

---

#### 2️⃣ 核心思想（一句话）

> **不拷贝资源，只转移资源所有权**

---

#### 3️⃣ 标准写法

```cpp
class A {
public:
    int* p;

    A(int x = 0) {
        p = new int(x);
    }

    // 移动构造
    A(A&& other) noexcept {
        p = other.p;      // ① 接管资源
        other.p = nullptr; // ② 让对方变成“空壳”
    }

    ~A() {
        delete p;
    }
};
```

为什么要把 `other.p = nullptr`？

* 防止析构时 double delete

---

### 五、移动赋值运算符（Move Assignment）

```cpp
A& operator=(A&& other) noexcept {
    if (this == &other)
        return *this;

    delete p;             // ① 清理自己原有资源
    p = other.p;          // ② 接管资源
    other.p = nullptr;    // ③ 对方清空
    return *this;
}
```

---

### 六、Rule of Five（五法则）

如果你管理资源，通常需要：

1. 析构函数
2. 拷贝构造
3. 拷贝赋值
4. **移动构造**
5. **移动赋值**

👉 称为 **Rule of Five**

---

### 七、`std::move` 的本质（重点）

#### ❗一个常见误解

> ❌ `std::move` 会“移动对象”

这是 **错误的**。

---

#### ✅ 真相

```cpp
std::move(x)
```

本质只是：

> **把 x 强制转换成右值引用**

等价于：

```cpp
static_cast<T&&>(x)
```

👉 真正“动手搬资源”的，是 **移动构造 / 移动赋值函数**。

---

### 八、什么时候该用 std::move？

✅ 当你确定：

* 这个对象 **之后不会再用**
* 或者允许它变成“空壳”

❌ 不要对还要使用的对象随便 move

---
 从“避免 bug”到“写出高性能代码”的关键一步

👉 下一步推荐：**Day11 —— 智能指针（unique_ptr / shared_ptr）**
