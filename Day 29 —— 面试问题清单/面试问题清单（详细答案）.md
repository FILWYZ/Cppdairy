以下答案均按 **“结论 → 原理 → 工程视角”** 组织。

---

## 1. 为什么 vector 的扩容是指数级？

**结论**：平衡拷贝成本与内存浪费。

**原理**：

* 线性扩容会导致 O(n²) 拷贝
* 指数扩容保证摊还 O(1)

**工程**：

* 频繁 push_back 前应 reserve

---

## 2. vector 在什么场景下一定不适合？

* 频繁头部插入
* 需要稳定迭代器

---

## 3. 迭代器失效的本质原因？

* 内存重分配
* 节点被删除

---

## 4. map vs unordered_map？

* map：红黑树，有序，O(log n)
* unordered_map：哈希表，无序，平均 O(1)

---

## 5. unordered_map 什么时候退化？

* 哈希冲突严重
* rehash 频繁

---

## 6. 为什么 list 不推荐？

* cache 不友好
* 额外指针开销

---

## 7. 如何选择容器？

* 访问模式优先
* 修改频率其次

---

## 8. 什么是稳定迭代器？

* 插入/删除不影响已有迭代器

---

## 9–12（算法库简答）

* sort：introsort
* list 用 sort 成员函数
* find 是线性
* transform 适合函数式处理

---

## 13–18（现代 C++）

* auto 提升可维护性，但避免隐藏类型
* nullptr 解决 NULL 二义性
* range-for 基于 begin/end
* lambda 捕获注意生命周期
* constexpr 让计算前移到编译期
* enum class 强类型

---

## 19–24（RAII / 异常）

* RAII：资源生命周期绑定对象
* 析构在栈展开时自动调用
* 优先 unique_ptr
* weak_ptr 破环引用环
* shared_ptr 有原子计数成本
* 析构函数避免抛异常

---

## 25–30（工程）

* 头文件是接口
* 前向声明降低耦合
* target 是构建最小单元
* out-of-source 保持干净
* 重构是结构升级
* 现代工程：RAII + CMake + 清晰所有权

---

## 终极总结

> 面试不是考你记住多少细节，而是判断你是否具备构建、维护和演进 C++ 工程的能力。
