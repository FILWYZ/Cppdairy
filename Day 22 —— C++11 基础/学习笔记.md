# auto / nullptr / range-for

本节目标：**理解 C++11 三个最基础但最容易被“用错”的特性**，建立正确、可长期复用的使用准则。

---

## 一、为什么 C++11 是分水岭？

* 从“接近 C”的语言
* 迈向“现代系统语言”

`auto / nullptr / range-for` 是现代 C++ 的**起点特征**。

---

## 二、`auto`

### 1. auto 的本质

* **类型占位符**
* 编译期类型推导
* 不是动态类型

```cpp
auto x = 10;      // int
auto y = x;       // int
```

---

### 2. auto 的工程价值

* 减少冗余类型书写
* 避免类型不一致错误
* 提高模板代码可读性

---

### 3. auto 的常见误区

#### （1）auto 会丢失引用？

```cpp
int a = 10;
int& r = a;
auto x = r;   // int（拷贝）
auto& y = r;  // int&
```

---

#### （2）auto 与 const

```cpp
const int c = 10;
auto x = c;        // int
const auto y = c; // const int
```

---

## 三、`nullptr`

### 1. nullptr 出现的原因

* `NULL` 是整数常量（0）
* 引发函数重载歧义

```cpp
void f(int);
void f(char*);

f(NULL);     // 歧义
f(nullptr);  // 调用 f(char*)
```

---

### 2. nullptr 的类型

* 类型：`std::nullptr_t`
* 只能表示空指针

---

### 3. 使用准则

> **现代 C++ 中，永远不用 NULL，只用 nullptr**。

---

## 四、`range-for`

### 1. 语法形式

```cpp
for (auto& x : container) {
    // use x
}
```

---

### 2. 背后机制（简化）

* 调用 `begin()` / `end()`
* 通过迭代器遍历

---

### 3. 值 / 引用的选择

```cpp
for (auto x : v)    // 拷贝
for (auto& x : v)  // 可修改
for (const auto& x : v) // 只读（推荐）
```

---

## 五、三者的组合使用

```cpp
for (const auto& [k, v] : mp) {
    // C++17 才支持结构化绑定
}
```

> C++11 为现代 C++ 奠定语法基础。

---

## 六、工程级总结

* auto：减少噪音，但要清楚类型
* nullptr：类型安全的空指针
* range-for：语义化遍历

---

## 七、面试级总结

> C++11 的基础特性看似简单，但是否理解“类型、引用与语义”，决定了代码质量的上限。
