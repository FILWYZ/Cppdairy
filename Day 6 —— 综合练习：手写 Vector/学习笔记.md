## 一、Day 6 的真正目的

> 不是为了造轮子，而是为了回答一个问题：
>
> **你是否真正理解了 C++ 的内存模型？**

如果你能：

* 正确 new / delete
* 不泄漏
* 不越界
* 不 double free

那么：
👉 你已经具备 **C++ 后端工程师的底层能力**。

---

## 二、我们要实现什么？（极简但完整）

### 功能范围（刻意限制）

```cpp
class MyVector {
public:
    void push_back(int x);
    int size() const;
    int operator[](int idx) const;
};
```

支持：

* 动态扩容
* 连续内存

不支持（刻意不做）：

* 模板
* 迭代器
* 异常安全（下一阶段）

---

## 三、Vector 的核心数据结构

```cpp
class MyVector {
private:
    int* data_;      // 指向堆内存
    size_t size_;    // 已存元素个数
    size_t cap_;     // 当前容量
};
```

### 各成员的职责

* `data_`：

  * 所有权明确
  * 必须 delete[]

* `size_`：

  * 实际使用长度

* `cap_`：

  * 决定是否扩容

👉 **这是所有动态数组的通用模型**。

---

## 四、push_back 的本质（核心逻辑）

```text
if (size < capacity)
    直接写
else
    申请新内存
    拷贝旧数据
    释放旧内存
    更新指针
```

📌 这是 C++ 内存管理能力的集中体现。

---

## 五、最容易犯的 5 个致命错误

1. 忘记 delete[]
2. 扩容后还用旧指针
3. 拷贝长度错误
4. cap_ 不更新
5. 析构函数缺失

👉 本 Day 你会至少踩中 1–2 个，这是正常的。

---
