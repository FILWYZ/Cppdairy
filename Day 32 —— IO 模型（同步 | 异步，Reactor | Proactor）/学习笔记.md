本节目标：  
**把“IO 模型、Reactor / Proactor”这些容易混淆的概念，整理为清晰、可面试、可工程落地的认知体系。**

---

## 一、为什么 IO 模型是网络编程的分水岭？

很多 C++ 后端开发者：

* 会用 epoll
* 听过 Reactor
* 甚至用过某些网络库

但一旦被追问：

* 同步和异步到底差在哪？
* Reactor 和 Proactor 的本质区别是什么？

回答往往开始混乱。

原因只有一个：

> **把 IO 模型当成“名词”，而不是“责任划分方式”。**

---

## 二、理解 IO 模型的核心视角

理解 IO 模型，必须先明确一个问题：

> **“谁在等 IO 结果？”**

IO 模型的差异，本质就在于：

* 等待 IO 的是：
  * 应用线程？
  * 内核？
* 数据拷贝完成后：
  * 谁来通知？
  * 谁来处理？

---

## 三、同步 IO 的本质

同步 IO 的核心特征只有一句话：

> **IO 的完成，必须由应用线程主动参与并等待结果。**

无论是：

* 阻塞 IO
* 非阻塞 IO
* IO 多路复用

它们都属于：

> **同步 IO 模型**

因为最终：

* 数据是否就绪
* 数据是否拷贝完成  
都需要应用线程亲自确认。

---

## 四、异步 IO 的本质

异步 IO 与同步 IO 的根本区别在于：

> **应用线程把 IO 的“等待 + 拷贝”都交给内核。**

行为特征：

* 应用发起 IO 请求后立即返回
* 内核完成：
  * 等待数据
  * 数据拷贝
* 完成后主动通知应用

一句话总结：

> **异步 IO = 内核全权负责，应用只处理结果。**

---

## 五、Reactor 模式解决了什么问题？

Reactor 并不是 IO 模型，而是：

> **同步 IO 场景下的一种事件分发架构模式。**

它要解决的问题是：

* 多路 IO 就绪事件
* 如何高效分发给对应的处理逻辑

---

## 六、Reactor 的核心思想

Reactor 模式的责任划分：

* 内核：负责 IO 就绪通知
* Reactor：负责事件分发
* Handler：负责数据读写与业务处理

关键点：

> **IO 读写仍然由应用线程完成，因此 Reactor 属于同步 IO。**

---

## 七、Proactor 模式的设计初衷

Proactor 的核心目标是：

> **彻底把 IO 操作交给内核，应用只关心“完成事件”。**

责任划分：

* 内核：
  * 等待 IO
  * 执行 IO
  * 拷贝数据
* 应用：
  * 处理完成后的结果

因此：

> **Proactor 天然对应异步 IO 模型。**

---

## 八、Reactor vs Proactor 本质对比

| 维度 | Reactor | Proactor |
|----|----|----|
| IO 模型 | 同步 IO | 异步 IO |
| IO 操作 | 应用线程执行 | 内核执行 |
| 通知时机 | IO 就绪 | IO 完成 |
| 编程复杂度 | 较低 | 较高 |

---

## 九、本节总结

> IO 模型决定的是“谁为 IO 等待买单”，  
> 架构模式决定的是“事件如何被组织和分发”。  

理解清楚责任边界，  
比记住名词重要得多。
