### 一、为什么要手写 String？

因为 `String` 类 **几乎涵盖了 C++ 内存管理的所有核心问题**：

* 动态内存（`char*`）
* 构造 / 析构
* 拷贝构造 / 拷贝赋值
* 移动构造 / 移动赋值
* RAII
* Rule of Five

👉 能写对一个 `String`，说明你真的“会 C++”。

---

### 二、String 类要解决的核心问题

一个最简 String 至少要解决：

1. 内部持有一块动态字符数组
2. 正确管理生命周期（不泄漏 / 不 double free）
3. 拷贝时是 **深拷贝**
4. 移动时是 **资源转移**

---

### 三、Rule of Five（再次强化）

只要你：

* 自己管理资源（`new[] / delete[]`）

那你就应该考虑实现：

1. 析构函数
2. 拷贝构造函数
3. 拷贝赋值运算符
4. 移动构造函数
5. 移动赋值运算符

---

### 四、String 类的设计（最小但完整）

```cpp
class String {
private:
    char* data_;
    size_t size_;

public:
    // 1. 默认构造
    String() : data_(nullptr), size_(0) {}

    // 2. 从 C 字符串构造
    String(const char* s);

    // 3. 析构函数
    ~String();

    // 4. 拷贝构造
    String(const String& other);

    // 5. 拷贝赋值
    String& operator=(const String& other);

    // 6. 移动构造
    String(String&& other) noexcept;

    // 7. 移动赋值
    String& operator=(String&& other) noexcept;
};
```

---

### 五、实现思路拆解（非常重要）

#### 1️⃣ 构造函数

* 分配新内存
* 拷贝字符内容

#### 2️⃣ 析构函数

* `delete[] data_`

#### 3️⃣ 拷贝构造

* **重新分配内存**
* 拷贝内容（深拷贝）

#### 4️⃣ 拷贝赋值

* 处理自赋值
* 释放旧资源
* 深拷贝新内容

#### 5️⃣ 移动构造 / 移动赋值

* 直接接管指针
* 把源对象置空

---
