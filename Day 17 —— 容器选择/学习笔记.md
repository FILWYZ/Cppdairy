## 1. 总览：选择容器的核心维度

在 C++ STL 中，常见容器可按以下特性选择：

| 容器                  | 内存结构      | 访问效率               | 插入/删除效率            | 是否有序  | 迭代器稳定性        | 使用场景              |
| ------------------- | --------- | ------------------ | ------------------ | ----- | ------------- | ----------------- |
| vector              | 连续数组      | O(1)               | 尾部 O(1), 头/中 O(n)  | ❌     | 扩容时失效         | 动态数组、尾部频繁插入、随机访问  |
| deque               | 分段连续      | O(1)               | 两端 O(1), 中间 O(n)   | ❌     | 部分迭代器失效       | 双端队列、两端操作频繁       |
| list / forward_list | 链表        | O(n)               | O(1)               | ❌     | 稳定            | 频繁插入/删除，中间操作多     |
| map                 | 红黑树       | O(log n)           | O(log n)           | ✅     | 插入稳定，删除被删节点失效 | 有序 key/value、区间查询 |
| unordered_map       | 哈希表       | 平均 O(1)            | 平均 O(1)            | ❌     | rehash 后全部失效  | 高频查找，无序、hash 均匀   |
| set / unordered_set | 红黑树 / 哈希表 | O(log n) / 平均 O(1) | O(log n) / 平均 O(1) | ✅ / ❌ | 同 map         | 去重场景              |

> 核心原则：**访问模式 + 插入/删除模式 + 是否有序 + 数据量预估**

---

## 2. 访问效率考量

* **随机访问频繁 → vector / deque**
* **中间访问多 → map / list 不适合**
* **顺序访问 → vector / deque 优先**

> Cache 友好性是关键因素

---

## 3. 插入/删除效率考量

| 场景     | 建议容器                          |
| ------ | ----------------------------- |
| 尾部频繁插入 | vector                        |
| 两端频繁插入 | deque                         |
| 中间频繁插入 | list / forward_list           |
| 有序插入   | map / set                     |
| 无序快速插入 | unordered_map / unordered_set |

---

## 4. 有序 vs 无序

* 需要 **顺序遍历或区间查询 → map / set**
* 不关心顺序、追求性能 → unordered_map / unordered_set
* 频繁排序场景，vector + sort 有时比 map 更快（局部小数据集）

---

## 5. 迭代器稳定性与指针引用

* **vector / deque**：扩容或跨 bucket 可能失效
* **list / forward_list**：插入/删除仅影响对应节点，迭代器稳定
* **map / set**：插入稳定，删除被删节点失效
* **unordered_map / unordered_set**：rehash 后全部失效

> 迭代器稳定性直接影响工程设计，尤其是缓存对象或长期持有迭代器的场景

---

## 6. 实际场景分析示例

| 场景             | 推荐容器                | 原因              |
| -------------- | ------------------- | --------------- |
| 日志缓冲区，频繁尾部写入   | vector / deque      | 尾部操作快，顺序访问友好    |
| 双端队列任务调度       | deque               | 两端入队出队均 O(1)    |
| 高速缓存结构，需要迭代器稳定 | list                | 插入/删除稳定，避免迭代器失效 |
| 配置表，按 key 排序访问 | map                 | 有序访问、区间查询便利     |
| 高速查找，不需要排序     | unordered_map       | 平均 O(1) 查找      |
| 唯一元素集合         | set / unordered_set | 去重特性，按需选择有序或无序  |

---

## 7. 容器选择总结原则

1. **访问模式**：随机访问 vs 顺序访问
2. **插入/删除模式**：尾部、中间、两端频繁插入删除
3. **有序要求**：是否需要 key 排序或区间查询
4. **数据量预估与性能稳定性**：是否能承受最坏复杂度
5. **迭代器稳定性**：是否需要长期持有迭代器或引用

---

## 8. 面试一句话总结

> 容器选择 = **访问模式 + 插入/删除位置 + 是否有序 + 数据量预估 + 迭代器稳定性**，记住场景对应原则，剩下交给 STL 实现。
