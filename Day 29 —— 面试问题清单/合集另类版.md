# Day 29 —— 面试问题清单（自问自答 30 题）

> 适用人群：  
> ✅ C++ 学习约 3 个月  
> ✅ 掌握基础语法、STL、简单数据结构  
> ✅ 目标岗位：C++ 后端工程师 / 系统方向初级工程师  

本清单用于 **面试前自检**：  
不是“会不会背答案”，而是——  
👉 **你是否已经具备「工程师视角」**

---

## 一、语言与内存基础（1–8）

### 1. C++ 中 new / delete 和 malloc / free 的区别？

**答：**
- new/delete：
  - 调用构造 / 析构函数
  - 类型安全
  - 可重载
- malloc/free：
  - 只分配 / 释放内存
  - 不关心类型
  - 不能调用构造函数

👉 **工程中优先使用 new/delete 或 STL 容器**

---

### 2. 什么是 RAII？为什么重要？

**答：**
- RAII：资源获取即初始化
- 对象生命周期 = 资源生命周期
- 析构函数中自动释放资源

👉 防止：
- 内存泄漏
- 文件句柄泄漏
- 异常路径遗漏释放

---

### 3. 指针和引用的核心区别？

**答：**
- 指针可以为空、可修改指向
- 引用必须初始化、不可重新绑定
- 引用更安全，语义更清晰

👉 **接口参数优先用引用**

---

### 4. 什么是浅拷贝？什么是深拷贝？

**答：**
- 浅拷贝：只拷贝指针
- 深拷贝：拷贝指针指向的资源

👉 拥有资源的类必须实现：
- 拷贝构造
- 拷贝赋值
- 析构函数（Rule of 3）

---

### 5. 什么情况下必须写拷贝构造函数？

**答：**
- 类中有：
  - 动态内存
  - 文件 / socket / mutex
- 默认拷贝会导致：
  - double free
  - 资源共享错误

---

### 6. 什么是移动语义？解决了什么问题？

**答：**
- 用“偷资源”代替“深拷贝”
- 避免不必要的内存分配

👉 提升：
- vector 扩容
- 返回值性能

---

### 7. const 修饰成员函数的意义？

**答：**
- 承诺不修改对象状态
- const 对象只能调用 const 成员函数

👉 是**接口设计的一部分**

---

### 8. nullptr 比 NULL 好在哪里？

**答：**
- nullptr 是类型安全的指针
- 避免函数重载歧义

---

## 二、STL 与容器理解（9–16）

### 9. vector 的底层结构？为什么遍历快？

**答：**
- 连续内存
- cache 命中率高
- 支持随机访问

---

### 10. vector 扩容发生了什么？

**答：**
1. 申请更大内存
2. 移动 / 拷贝旧元素
3. 释放旧内存

👉 导致：
- 迭代器 / 指针失效

---

### 11. 为什么不推荐使用 list？

**答：**
- 非连续内存
- cache miss 严重
- 遍历性能极差

👉 **99% 场景 vector 更优**

---

### 12. map 和 unordered_map 的区别？

**答：**
- map：红黑树，O(log n)，有序
- unordered_map：哈希表，平均 O(1)，无序

---

### 13. unordered_map 什么时候会退化？

**答：**
- 哈希函数差
- 大量 key 落入同一 bucket

👉 最坏 O(n)

---

### 14. STL 算法为什么比手写 for 好？

**答：**
- 语义清晰
- 易优化
- 少 bug
- 可并行（C++17）

---

### 15. sort 的复杂度？底层实现？

**答：**
- 平均 / 最坏：O(n log n)
- 实现：Introsort

---

### 16. find 和容器成员 find 的区别？

**答：**
- std::find：线性查找
- 容器 find：利用内部结构

👉 set / map 必须用成员函数

---

## 三、工程与系统认知（17–24）

### 17. 什么是内存泄漏？常见原因？

**答：**
- new 后未 delete
- 异常路径提前 return
- 循环引用

---

### 18. shared_ptr 和 unique_ptr 的区别？

**答：**
- unique_ptr：独占所有权
- shared_ptr：引用计数共享

👉 默认优先 unique_ptr

---

### 19. weak_ptr 的作用？

**答：**
- 打破 shared_ptr 循环引用
- 不影响引用计数

---

### 20. 为什么析构函数常设为 virtual？

**答：**
- 通过基类指针 delete 派生对象
- 防止资源泄漏

---

### 21. 什么是 ODR（One Definition Rule）？

**答：**
- 一个符号在程序中只能有一个定义
- 常见错误：头文件中定义变量

---

### 22. inline 真的会内联吗？

**答：**
- 只是建议
- 是否内联由编译器决定

---

### 23. static 在不同位置的含义？

**答：**
- 函数内：静态生命周期
- 文件级：内部链接
- 类内：类共享成员

---

### 24. 什么是未定义行为（UB）？

**答：**
- 编译器不保证任何结果
- 可能：
  - 看似正常
  - 随机崩溃
  - 线上才出问题

👉 比 bug 更危险

---

## 四、后端工程思维（25–30）

### 25. 如何选择容器？

**答：**
- 默认 vector
- 查找频繁 → unordered_map
- 有序 → map

---

### 26. 什么是“性能瓶颈”的第一来源？

**答：**
- 内存访问
- cache miss
- 不必要的拷贝

👉 不是 CPU 算力

---

### 27. 为什么要避免裸 new / delete？

**答：**
- 易泄漏
- 异常不安全

👉 用：
- STL 容器
- 智能指针

---

### 28. 后端代码最重要的三点？

**答：**
1. 正确性
2. 可维护性
3. 可扩展性

---

### 29. 什么是“工程代码”和“刷题代码”的区别？

**答：**
- 工程代码：
  - 边界清晰
  - 错误可控
  - 易读易维护
- 刷题代码：
  - 只为通过测试

---

### 30. 如果现在让你写一个后端模块，你最先考虑什么？

**答：**
- 接口设计
- 生命周期管理
- 错误处理策略
- 数据结构选择

👉 **而不是直接写代码**

---

## 结语

> 能答完这 30 题，并且理解“为什么”，  
> 你已经从 **C++ 学习者**，迈入 **后端工程师思维的门槛**。

下一步建议：
- 补项目
- 读源码
- 做真实工程拆解

📌 **不要再只刷题了。**
