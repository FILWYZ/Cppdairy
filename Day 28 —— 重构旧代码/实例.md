通过**逐步演进示例**，演示如何将旧式 C++ 重构为现代 RAII 风格。

---

## 示例一：典型旧代码（问题示例）

```cpp
class File {
public:
    File(const char* path) {
        fp = fopen(path, "r");
    }

    void read() {
        // 使用 fp
    }

    void close() {
        if (fp) fclose(fp);
    }

private:
    FILE* fp;
};
```

问题：

* 忘记调用 `close`
* 异常不安全

---

## 示例二：RAII 化重构

```cpp
class File {
public:
    explicit File(const char* path)
        : fp(fopen(path, "r")) {}

    ~File() {
        if (fp) fclose(fp);
    }

    void read() {
        // 使用 fp
    }

private:
    FILE* fp;
};
```

改进点：

* 构造即获取资源
* 析构自动释放

---

## 示例三：new/delete → unique_ptr

### 旧代码

```cpp
Node* n = new Node();
process(n);
delete n;
```

---

### 重构后

```cpp
auto n = std::make_unique<Node>();
process(n.get());
```

---

## 示例四：所有权转移

```cpp
std::unique_ptr<Node> create() {
    return std::make_unique<Node>();
}
```

说明：

* 明确所有权返回

---

## 示例五：shared_ptr 使用场景

```cpp
auto a = std::make_shared<A>();
auto b = a; // 共享所有权
```

注意：

* 必须确认确实需要共享

---

## 示例六：用 RAII 管理锁

```cpp
std::mutex m;

void f() {
    std::lock_guard<std::mutex> lk(m);
    // 临界区
}
```

---

## 实战总结

* 用析构函数兜底
* 所有权必须能从代码中读出来
* 智能指针数量越少，设计越清晰
