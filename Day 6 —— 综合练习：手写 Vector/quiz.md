## 题 1（基础）

❓ 为什么扩容时不能直接使用原数组？

### ✅ 答案

* 原内存大小固定
* 继续写会越界

---

## 题 2（内存管理）

❓ 扩容时为什么一定要先拷贝再 delete？

### ✅ 面试级答案

* delete 后原数据丢失
* 无法再访问

---

## 题 3（析构函数）

❓ 如果 MyVector 没有析构函数会发生什么？

### ✅ 答案

* data_ 指向的堆内存永远无法释放
* 程序结束前 Valgrind 报泄漏

---

## 题 4（进阶）

❓ 这个 MyVector 为什么不能安全拷贝？

### ✅ 面试级答案

* 默认拷贝是浅拷贝
* 两个对象共享同一块 data_
* 析构时 double free

👉 这正是 Day 7 的主题。

---

## Day 6 自检清单（非常重要）

* [ ] 我能独立写出 push_back 扩容逻辑
* [ ] 我知道 new[] / delete[] 必须成对
* [ ] 我用 Valgrind 验证了 0 泄漏
* [ ] 我理解为什么默认拷贝是危险的

---

## 🧠 Day 6 核心认知

> **写过一次 Vector，你就再也不会“随便用 new/delete”了。**

从这一刻开始：

* 你知道标准库有多难
* 你也真正理解了 RAII 的必要性

---
