## 一、基础理解题

### 题 1：为什么 vector 适合尾部频繁插入？

#### 答案

* 尾部插入均摊 O(1)
* 内存连续，顺序访问 cache 友好

---

### 题 2：deque 和 vector 的区别是什么？

#### 答案

* deque 支持两端 O(1) 插入/删除
* vector 只支持尾部 O(1)
* 内存结构：vector 连续，deque 分段连续

---

## 二、迭代器稳定性题

### 题 3：list 的迭代器稳定性特点？

#### 答案

* 插入/删除只影响对应节点迭代器
* 长期持有迭代器安全

---

### 题 4：map 与 unordered_map 插入后迭代器稳定性？

#### 答案

* map：插入不失效，删除被删节点失效
* unordered_map：插入可能触发 rehash → 全部迭代器失效

---

## 三、选型判断题

### 题 5：场景选择容器

| 场景         | 推荐容器                | 原因            |
| ---------- | ------------------- | ------------- |
| 日志缓冲区，尾部写入 | vector              | 尾部 O(1)、顺序访问快 |
| 双端任务队列     | deque               | 两端操作 O(1)     |
| 中间频繁插入/删除  | list                | 插入/删除稳定，迭代器安全 |
| 有序配置表      | map                 | 有序、区间查询方便     |
| 高频查找，无序    | unordered_map       | 平均 O(1)       |
| 唯一元素集合     | set / unordered_set | 去重特性          |

---

### 题 6：什么时候 vector 不适合？

#### 答案

* 中间插入/删除频繁
* 长期持有迭代器或指针（扩容可能失效）
* 超大数据且频繁扩容

---

## 四、面试思考题

### 题 7：为什么有序小集合，vector+sort 有时比 map 更快？

#### 答案

* 小规模数据，排序成本低
* 连续内存顺序访问，cache 友好
* map 红黑树插入每次 O(log n)，常数较大

---

### 题 8：迭代器长期持有场景，容器如何选择？

#### 答案

* 避免 vector/deque 跨扩容
* list / map / set 迭代器稳定，适合长期持有

---

### 题 9：工程设计原则总结

> 容器选择 = **访问模式 + 插入/删除位置 + 是否有序 + 数据量预估 + 迭代器稳定性**
