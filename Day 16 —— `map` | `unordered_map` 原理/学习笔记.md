## 1. 总览：`map` 与 `unordered_map`

| 容器                   | 底层结构 | 是否有序 | 迭代器顺序    | 查找复杂度    |
| -------------------- | ---- | ---- | -------- | -------- |
| `std::map`           | 红黑树  | ✅    | 按 key 升序 | O(log n) |
| `std::unordered_map` | 哈希表  | ❌    | 无序       | 平均 O(1)  |

> 核心区别：**有序平衡树 vs 哈希结构**

---

## 2. `std::map` —— 红黑树原理

### 2.1 为什么选择红黑树？

红黑树是一种 **自平衡二叉搜索树**，满足：

* 任意节点左右子树满足 BST 性质
* 树的高度始终保持 `O(log n)`

这保证了：

* `find / insert / erase` 均为 **O(log n)**
* 不会退化成链表

---

### 2.2 红黑树的核心性质（了解层面）

1. 节点非红即黑
2. 根节点为黑
3. 红节点不能相邻
4. 任一路径黑节点数相同

> 这些约束保证了树的近似平衡

---

### 2.3 `map` 的工程特性

* 元素 **自动按 key 排序**
* 迭代器 **稳定**（插入不会使其失效）
* 支持区间操作：`lower_bound / upper_bound / equal_range`

---

## 3. `std::unordered_map` —— 哈希表原理

### 3.1 哈希表基本结构

```text
bucket[0] -> 链表 / 桶
bucket[1]
bucket[2]
...
```

* key 经过 `hash(key)` 映射到 bucket
* bucket 中存储冲突元素

---

### 3.2 哈希冲突（collision）

冲突不可避免，常见解决方式：

* **拉链法（STL 使用）**
* 开放定址法（STL 未采用）

---

### 3.3 load factor（负载因子）

```cpp
load_factor = size / bucket_count
```

* 默认最大负载因子 ≈ `1.0`
* 超过阈值 → **rehash**

---

## 4. 复杂度对比与退化问题

### 4.1 理论复杂度

| 操作 | map      | unordered_map |
| -- | -------- | ------------- |
| 查找 | O(log n) | 平均 O(1)       |
| 插入 | O(log n) | 平均 O(1)       |
| 删除 | O(log n) | 平均 O(1)       |

---

### 4.2 `unordered_map` 的复杂度退化

在以下情况下：

* 哈希函数设计不当
* 大量 key 映射到同一 bucket

会导致：

```text
查找 / 插入 / 删除 → O(n)
```

本质原因：

> bucket 退化为链表

---

### 4.3 `map` 不存在复杂度退化

* 红黑树高度有严格上界
* 最坏情况仍为 `O(log n)`

这也是 `map` 在 **安全性与可预测性** 上的优势

---

## 5. rehash 与 iterator 失效

### 5.1 `unordered_map::rehash`

* bucket 数量改变
* 所有元素重新分布

影响：

* **所有迭代器失效**
* 引用 / 指针失效

---

### 5.2 `map` 的迭代器稳定性

* 插入：不失效
* 删除：仅被删元素失效

---

## 6. 工程选型总结

* 需要 **有序 / 区间查询 / 稳定复杂度** → `map`
* 需要 **极致查找性能** → `unordered_map`
* 哈希质量不确定 / 对最坏情况敏感 → `map`

---

## 7. 面试一句话总结

> `map` 用红黑树保证 `O(log n)` 的稳定复杂度；
> `unordered_map` 用哈希换取平均 `O(1)`，但最坏可退化到 `O(n)`。
