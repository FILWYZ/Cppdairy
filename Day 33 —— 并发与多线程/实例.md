本节目标：  
**通过真实工程场景，理解并发工具是如何一步步演变为系统设计问题的。**

---

## 一、为什么并发问题往往出现在“没改过的代码里”？

在很多线上事故中：

* 出问题的代码很久没动过
* 新功能只是“触发条件”

根本原因是：

> **并发问题通常是“设计债务”，不是最近的改动。**

---

## 二、mutex 使用不当的工程后果

### 常见场景

* 锁粒度过大
* 所有逻辑共用一把锁

结果是：

* 并发度极低
* 性能无法扩展
* 线程大量阻塞

工程结论：

> **锁的设计，直接决定系统的吞吐上限。**

---

## 三、condition_variable 的典型工程场景

### 场景：生产者 - 消费者模型

如果没有 condition_variable：

* 消费线程只能不断轮询
* CPU 空转严重

使用 condition_variable 后：

* 条件不满足 → 线程休眠
* 条件满足 → 精确唤醒

工程价值：

> **把“时间浪费”变成“事件驱动”。**

---

## 四、原子操作的工程边界

在工程中常见的误用是：

* 用原子变量实现复杂状态机

结果：

* 逻辑难以理解
* 内存序问题隐蔽
* Bug 难以复现

正确认知：

> **原子操作适合“点状问题”，不适合“面状设计”。**

---

## 五、线程池设计中的关键取舍

一个典型线程池设计，需要权衡：

* 线程数量 vs CPU 核心数
* 队列长度 vs 延迟
* 拒绝策略 vs 稳定性

工程结论：

> **线程池设计，本质是容量规划问题。**

---

## 六、死锁在工程中是如何被“设计出来的”？

典型场景：

* 多把锁
* 加锁顺序不一致
* 锁作用域过大

结果：

* 线程相互等待
* 系统停滞

重要结论：

> **死锁往往在设计阶段就已经注定。**

---

## 七、工程级总结

> 并发工具只是“零件”，  
> 并发设计才是“结构”。  

优秀的并发代码，  
往往看起来简单、克制、边界清晰。
