本节是 **Day 15–20 的总收官**，目标不是再讲新知识，而是沉淀一套**可长期使用的 STL 工程准则**。

> STL 用得好不好，区别不在“会不会”，而在“是否遵循正确准则”。

---

## 一、核心思想总览

### 1. STL 的三大设计核心

1. **数据结构**：容器
2. **行为抽象**：算法
3. **访问协议**：迭代器

> STL 的精髓在于：
> **数据、算法、内存三者解耦，但通过约束协同工作。**

---

## 二、容器使用准则

### 准则 1：优先使用连续内存容器

* 默认选择：`vector`
* cache 友好
* 遍历、查找极快

❌ 不要因为“插入 O(1)”就盲选 `list`

---

### 准则 2：是否需要“有序”是 map 的唯一理由

* 不需要排序 / 范围查询 → `unordered_map`
* 需要顺序 / 稳定性能 → `map`

---

### 准则 3：能不用 list 就不用

* list 的优势极其有限
* 真实工程中命中率很低

---

## 三、算法使用准则

### 准则 4：优先算法，而非手写循环

* `sort / find / transform`
* 语义清晰
* 易于维护

---

### 准则 5：查找优先容器成员函数

* `map::find` > `std::find`
* `unordered_map::find` > `std::find`

---

## 四、迭代器与安全准则

### 准则 6：时刻警惕迭代器失效

* vector 扩容
* unordered_map rehash

> **写 STL 代码，必须在脑中模拟迭代器生命周期。**

---

## 五、性能准则

### 准则 7：复杂度只是下界，不是性能

* cache
* 内存布局
* 常数因子

---

### 准则 8：先选对容器，再考虑优化

* 90% 性能问题来自容器选择错误

---

## 六、allocator 与高级特性准则

### 准则 9：allocator 是能力储备，不是日常工具

* 默认 allocator 已足够
* 只有在定位到瓶颈时才考虑

---

## 七、终极使用心法

> **STL 是工程工具箱，而不是炫技舞台。**

* 清晰 > 花哨
* 正确 > 聪明
* 稳定 > 极致

---

## 八、面试级总结

> 会 STL 是基础，用 STL 写出稳定、高性能、可维护代码，才是工程能力。
