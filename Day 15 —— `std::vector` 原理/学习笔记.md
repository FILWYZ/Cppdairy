## 1. `std::vector` 的本质

`std::vector` 是 **动态顺序容器**，其核心特征是：

* **连续内存（contiguous storage）**
* 支持 **随机访问 O(1)**
* 尾部插入/删除 **均摊 O(1)**
* 中间或头部插入/删除 **O(n)**

> 可以将 `vector` 理解为：
> **一段可以自动扩容的动态数组**。

---

## 2. 内部关键成员（概念层面）

典型实现中（以 libstdc++ / libc++ 为例），`vector` 内部维护三根指针：

```text
begin_        end_          cap_
  |------------|--------------|
  已使用元素     末尾           容量末尾
```

* `begin_`：首元素地址
* `end_`：最后一个元素的 **下一位置**
* `cap_`：当前分配内存的末尾

对应概念：

* `size()  = end_ - begin_`
* `capacity() = cap_ - begin_`

---

## 3. 扩容机制（Expansion / Reallocation）

### 3.1 何时触发扩容？

当执行：

* `push_back`
* `emplace_back`
* `insert`

且满足：

```cpp
size() == capacity()
```

就会触发 **重新分配（reallocation）**。

---

### 3.2 扩容的一般步骤

1. **申请更大的连续内存块**
2. **移动 / 拷贝原有元素到新内存**
3. **析构旧元素**
4. **释放旧内存**
5. **更新指针（begin / end / cap）**

> ⚠️ 注意：这是一次 **整体搬迁**，代价不小。

---

### 3.3 扩容倍率（非标准保证）

常见实现：

| STL 实现          | 扩容策略   |
| --------------- | ------ |
| libstdc++ (GCC) | 约 ×2   |
| libc++ (Clang)  | 约 ×2   |
| MSVC STL        | 约 ×1.5 |

⚠️ **C++ 标准并不保证扩容倍率**，只能保证：

* 扩容后 `capacity()` ≥ 原 `capacity()`

---

### 3.4 均摊复杂度（Amortized Complexity）

虽然单次扩容是 `O(n)`，但：

```text
push_back 的均摊时间复杂度 = O(1)
```

原因：

* 扩容次数是 **对数级**
* 搬迁成本被分摊到大量插入操作中

---

## 4. `reserve` 与 `resize`

### 4.1 `reserve(n)`

* 只影响 **capacity**
* 不构造元素
* 不改变 `size()`

```cpp
v.reserve(100);
```

用途：

* **避免多次扩容**
* 提高性能

---

### 4.2 `resize(n)`

* 改变 **size**
* 会构造 / 析构元素

```cpp
v.resize(10);   // 构造新元素
v.resize(3);    // 析构多余元素
```

---

## 5. 迭代器失效（Iterator Invalidation）

### 5.1 什么是迭代器失效？

当容器结构发生变化后：

* 迭代器
* 指针
* 引用

**不再指向原先合法元素**，继续使用即 **未定义行为（UB）**。

---

### 5.2 `vector` 迭代器失效的根本原因

> **连续内存 + 扩容整体搬迁**

一旦扩容：

* 原内存被释放
* 所有地址全部失效

---

### 5.3 各操作对迭代器的影响

| 操作                | 是否扩容 | 迭代器状态           |
| ----------------- | ---- | --------------- |
| `push_back`（无扩容）  | ❌    | **不失效**（end 例外） |
| `push_back`（触发扩容） | ✅    | **全部失效**        |
| `insert`（中间）      | 可能   | 插入点及之后失效        |
| `erase`           | ❌    | 被删位置及之后失效       |
| `clear`           | ❌    | **全部失效**        |
| `reserve`         | 可能   | 若扩容 → 全部失效      |

---

## 6. 设计层面的结论

* `vector` **适合**：

  * 随机访问
  * 尾部插入
  * cache-friendly 场景

* `vector` **不适合**：

  * 频繁头插 / 中插
  * 长期持有迭代器 / 指针

---

## 7. 面试 / 工程高频总结

> **一句话版**：

* `vector` 是连续内存动态数组
* 扩容会整体搬迁
* 扩容会导致所有迭代器、指针、引用失效
* `reserve` 是性能优化利器
