## 1. 为什么指针是 C++ 后端“事故重灾区”？

在真实后端系统中：

* **段错误（Segmentation Fault）** ≈ 指针问题
* **线上偶发崩溃** ≈ 悬空 / 野指针
* **安全漏洞** ≈ 非法内存访问

> 👉 指针不是“语法点”，而是 **内存访问权的表达式**。

---

## 2. 指针的本质（一句话）

> **指针 = 保存某块内存地址的变量**

但更工程化地说：

> **指针 = 对某段内存的“访问许可”**

一旦这段内存：

* 不存在
* 生命周期结束
* 被释放

👉 访问指针 = 未定义行为（UB）

---

## 3. 三类“致命指针”

### 3.1 野指针（Wild Pointer）

**定义**：

> 指向“未知地址”的指针

```cpp
int* p;      // 未初始化
*p = 10;     // ❌ 野指针写内存
```

**特点**

* 指向哪里完全随机
* 最危险、最难排查

**工程规范**

```cpp
int* p = nullptr;
```

---

### 3.2 悬空指针（Dangling Pointer）

**定义**：

> 指向“已经失效内存”的指针

```cpp
int* p = new int(10);
delete p;
*p = 20;    // ❌ 悬空指针
```

**常见来源**

* delete 后继续使用
* 返回局部变量地址

---

### 3.3 空指针（Null Pointer）

```cpp
int* p = nullptr;
```

* 不指向任何对象
* 访问会立即崩溃（反而安全）

---

## 4. 二级指针（指针的指针）

### 4.1 为什么需要二级指针？

> **当你需要“修改指针本身”时**

```cpp
void foo(int** p) {
    *p = new int(10);
}
```

**典型场景**

* 动态数组
* C 风格接口
* 输出型参数

---

### 4.2 常见错误

```cpp
void foo(int* p) {
    p = new int(10); // ❌ 只改了副本
}
```

---

## 5. 指针算术（Pointer Arithmetic）

### 5.1 基本规则

```cpp
int arr[3] = {1,2,3};
int* p = arr;

p + 1 == &arr[1];
```

* 步长 = sizeof(类型)
* 只允许在同一数组范围内

---

### 5.2 危险边界

```cpp
int* p = arr + 3; // 指向末尾后一个（合法但不能解引用）
*p = 10;         // ❌ UB
```

---

## 6. 后端工程师指针规范

* 所有指针初始化为 nullptr
* delete 后立刻置空
* 优先使用引用 / 智能指针

---
