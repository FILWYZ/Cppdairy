本节目标：**系统理解 lambda 的捕获规则与工程级使用场景**，避免“会写但不敢用、敢用但容易出错”。

---

## 一、为什么 lambda 是现代 C++ 的核心能力？

* 行为可以像数据一样被传递
* 算法、回调、并发的基础设施
* 极大提升 STL 与业务代码的表达力

> **lambda 是“轻量级函数对象”**。

---

## 二、lambda 的基本语法

```cpp
[capture](params) -> return_type {
    body;
}
```

* `capture`：捕获外部变量
* `params`：参数列表
* `return_type`：通常可省略

---

## 三、捕获规则（重点）

### 1. 值捕获 `[=]`

```cpp
int x = 10;
auto f = [=]() {
    // 拷贝 x
};
```

特性：

* 捕获时拷贝
* lambda 内修改不影响外部

---

### 2. 引用捕获 `[&]`

```cpp
int x = 10;
auto f = [&]() {
    x++;
};
```

特性：

* 修改影响外部变量
* 需保证生命周期

---

### 3. 混合捕获

```cpp
int a = 1, b = 2;
auto f = [a, &b]() {
    // a 值捕获，b 引用捕获
};
```

---

### 4. 捕获 this（C++11）

```cpp
auto f = [this]() {
    use(member);
};
```

风险：

* 仅捕获指针
* 对象析构后调用是 UB

---

## 四、mutable lambda

```cpp
int x = 0;
auto f = [x]() mutable {
    x++;
};
```

说明：

* 允许修改值捕获的副本
* 不影响外部变量

---

## 五、lambda 的类型本质

* 每个 lambda 都是 **匿名类**
* 重载 `operator()`
* 类型不可写出

因此：

* 用 `auto`
* 或 `std::function`

---

## 六、应用场景总结

### 1. STL 算法

```cpp
sort(v.begin(), v.end(), [](int a, int b){ return a > b; });
```

---

### 2. 回调 / 延迟执行

```cpp
register_callback([&](){ handle(); });
```

---

### 3. 局部策略 / 一次性逻辑

* 避免额外函数污染作用域

---

## 七、工程使用准则

1. 默认使用 **显式捕获**
2. 优先值捕获，慎用引用捕获
3. 回调 / 异步代码警惕生命周期

---

## 八、面试级总结

> lambda 是现代 C++ 中最重要的“行为抽象工具”，捕获方式决定安全性，使用场景决定价值。
