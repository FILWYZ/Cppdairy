本节目标：  
**通过工程视角，理解阻塞模型与连接队列是如何真实影响 C++ 网络服务行为的。**

---

## 一、为什么要从“阻塞行为”理解 Socket？

很多性能问题并不是代码写错，而是：

* 线程被阻塞
* 连接被堆积
* 但开发者毫无感知

本质原因是：

> **没有把 socket 行为和线程状态联系起来。**

---

## 二、阻塞 Socket 在工程中的真实表现

### 典型场景

* 单线程服务端
* 使用阻塞 accept / recv
* 并发连接增多

此时：

* accept 阻塞等待新连接
* recv 阻塞等待客户端数据
* 整个线程无法处理其他连接

工程后果：

* 吞吐量急剧下降
* 响应时间不可控

---

## 三、非阻塞 Socket 是如何改变行为的？

在非阻塞模式下：

* accept / recv 不再“等”
* 条件不满足立即返回
* 程序可以继续处理其他任务

但代价是：

> **程序必须自己管理“什么时候再来一次”。**

这也是：

* select / poll / epoll 存在的根本原因

---

## 四、半连接队列在工程中的作用

### 场景：连接突增

当大量客户端同时发起连接：

* SYN 请求先进入半连接队列
* 三次握手尚未完成

此时半连接队列的作用是：

> **防止瞬时洪峰直接冲垮服务端。**

---

## 五、全连接队列堆积的真实含义

当服务端：

* accept 处理不及时
* 或线程长期被阻塞

会导致：

* 已完成握手的连接堆积在全连接队列

工程结论：

> **全连接队列满，通常说明“应用层处理能力不足”。**

---

## 六、两个队列满了会发生什么？

* 半连接队列满：
  * 新 SYN 被丢弃或延迟
  * 客户端连接超时
* 全连接队列满：
  * 已完成握手的连接无法被 accept
  * 客户端表现为“连上但无响应”

---

## 七、工程级总结

> 阻塞模型决定的是“线程是否被绑死”，  
> 连接队列反映的是“系统能不能扛住并发”。  

真正的后端工程师，  
应该能通过连接异常，反推出瓶颈在 **内核层还是应用层**。
