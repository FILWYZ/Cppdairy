本节目标：**理解“编译期能力”在现代 C++ 中的地位**，搞清 constexpr 与 enum class 各自解决了什么工程问题。

---

## 一、为什么要强调“编译期”？

* 运行期：灵活，但有成本
* 编译期：

  * 零运行时开销
  * 更强的类型安全
  * 更早发现错误

> **现代 C++ 的一个核心方向：尽可能把事情提前到编译期完成。**

---

## 二、constexpr

### 1. constexpr 的本质

* 表示：**可在编译期求值**
* 不等于“必须在编译期执行”

```cpp
constexpr int x = 10;   // 编译期常量
```

---

### 2. constexpr vs const

| 对比项     | const | constexpr |
| ------- | ----- | --------- |
| 编译期常量   | 不保证   | 保证（条件满足）  |
| 可用于模板参数 | 有限制   | 可以        |

```cpp
const int a = f();      // 运行期
constexpr int b = 10;  // 编译期
```

---

### 3. constexpr 函数（C++11）

```cpp
constexpr int square(int x) {
    return x * x;
}
```

要求（C++11）：

* 函数体只有一条 return

---

### 4. constexpr 的工程价值

* 数组大小
* 模板参数
* 编译期计算

```cpp
constexpr int N = 16;
int arr[N];
```

---

## 三、enum class

### 1. 传统 enum 的问题

```cpp
enum Color { Red, Green };
int x = Red; // ❌ 隐式转换
```

问题：

* 污染作用域
* 可隐式转为 int

---

### 2. enum class 的改进

```cpp
enum class Color { Red, Green };
Color c = Color::Red;
```

优势：

* 强类型
* 不隐式转 int
* 作用域受限

---

### 3. enum class 底层类型

```cpp
enum class Status : uint8_t {
    OK, Error
};
```

---

## 四、constexpr + enum class

```cpp
enum class Size { Small = 4, Large = 8 };
constexpr int buf = static_cast<int>(Size::Large);
```

---

## 五、工程使用准则

* 常量优先 constexpr
* 枚举一律 enum class
* 不要再写裸 enum

---

## 六、面试级总结

> constexpr 是“编译期计算能力”，enum class 是“类型安全的枚举”，二者都是现代 C++ 安全性与性能的基础设施。
