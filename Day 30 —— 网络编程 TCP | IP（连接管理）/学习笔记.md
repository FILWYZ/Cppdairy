本节目标：  
**把“背得出流程图”的 TCP 三次握手、四次挥手，转化为“面试能讲清、工程能定位问题”的能力。**

---

## 一、为什么网络编程一定会考 TCP 连接？

很多 C++ 后端：

* socket 写过
* TCP 状态听过
* 却一到面试：
  * TIME_WAIT 说不清
  * CLOSE_WAIT 解释不准

原因只有一个：

> **把 TCP 当成“协议知识”，而不是“工程行为模型”。**

---

## 二、理解 TCP 之前必须先明确的前提

在讨论任何状态之前，先统一三点共识：

* TCP 是 **面向连接** 的
* TCP 是 **全双工** 的
* TCP 的目标是 **可靠、有序、不丢不重**

因此：

> **连接的建立与释放，本质是“双方状态达成一致”的过程。**

---

## 三、三次握手的本质是什么？

三次握手不是为了“建立连接”这么简单，而是为了确认三件事：

1. 客户端 → 服务端：能发
2. 服务端 → 客户端：能发
3. 当前连接不是历史遗留请求

一句话结论：

> **三次握手 = 双向通信能力确认 + 防止历史连接干扰。**

---

## 四、为什么不能是两次握手？

如果只有两次：

* 服务端无法确认：
  * 客户端是否能收到自己的 SYN
* 历史 SYN 包可能被当成新连接

工程后果：

* 连接状态不一致
* 资源被错误占用
* SYN Flood 风险增加

---

## 五、四次挥手的设计动机

理解四次挥手的关键只有一句话：

> **TCP 是全双工，关闭是“两个方向分别关闭”。**

因此：

* 一方不发数据 ≠ 另一方立刻断开
* 必须保证：
  * 已发送的数据能被完整接收

---

## 六、TIME_WAIT 的存在意义

TIME_WAIT 出现于：

* **主动关闭连接的一方**

它存在的两个核心原因：

1. 防止旧连接数据污染新连接
2. 确保对方能收到最后一个 ACK

关键认知：

> **TIME_WAIT 是协议层的“善后机制”，不是 Bug。**

---

## 七、CLOSE_WAIT 的真实含义

CLOSE_WAIT 出现条件：

* 已收到对方 FIN
* 应用层却迟迟没有 close socket

这意味着：

> **协议已经结束，但你的程序还没结束。**

---

## 八、TIME_WAIT vs CLOSE_WAIT

| 状态 | 出现方 | 本质 | 是否正常 |
|----|----|----|----|
| TIME_WAIT | 主动关闭方 | 协议保护 | ✅ |
| CLOSE_WAIT | 被动关闭方 | 程序未释放资源 | ❌ |

---

## 九、本节工程级总结

> TCP 状态不是让你背的，而是让你在看到状态时，  
> 能立刻反推出：**是谁关的？为什么关？代码哪里可能有问题？**
