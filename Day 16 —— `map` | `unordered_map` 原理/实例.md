通过示例直观展示：

* 有序 vs 无序
* 红黑树稳定性
* 哈希退化现象

---

## 示例 1：`map` 的有序性

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int, int> m;
    m[3] = 30;
    m[1] = 10;
    m[2] = 20;

    for (auto& [k, v] : m)
        cout << k << " ";
}
```

**输出**：

```text
1 2 3
```

---

## 示例 2：`unordered_map` 的无序性

```cpp
#include <unordered_map>
#include <iostream>
using namespace std;

int main() {
    unordered_map<int, int> um;
    um[3] = 30;
    um[1] = 10;
    um[2] = 20;

    for (auto& [k, v] : um)
        cout << k << " ";
}
```

⚠️ 输出顺序不确定

---

## 示例 3：迭代器稳定性对比

```cpp
map<int,int> m;
unordered_map<int,int> um;

m[1] = 1;
auto it1 = m.begin();

um[1] = 1;
auto it2 = um.begin();

m[2] = 2;   // it1 仍然有效
um[2] = 2;  // it2 可能失效（rehash）
```

---

## 示例 4：人为制造哈希退化

```cpp
#include <unordered_map>
using namespace std;

struct BadHash {
    size_t operator()(int) const {
        return 1; // 所有 key 落入同一 bucket
    }
};

int main() {
    unordered_map<int, int, BadHash> um;
    for (int i = 0; i < 10000; ++i)
        um[i] = i;
}
```

**结果**：

* bucket 退化为链表
* 操作复杂度 → `O(n)`

---

## 示例 5：控制 rehash

```cpp
unordered_map<int,int> um;
um.reserve(1000);

for (int i = 0; i < 1000; ++i)
    um[i] = i;
```

**作用**：

* 减少 rehash 次数
* 提高性能

---

## 工程实践建议

* `unordered_map` 必须：

  * 好的 hash
  * 合理 `reserve`
* 对最坏复杂度敏感 → `map`
