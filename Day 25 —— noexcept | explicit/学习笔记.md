本节目标：**理解“接口语义”在现代 C++ 中的重要性**。`noexcept` 与 `explicit` 并不改变功能，却深刻影响**安全性、性能与可维护性**。

---

## 一、为什么 noexcept / explicit 很重要？

* 它们不是语法糖
* 而是对「**接口行为的承诺**」

> 现代 C++ 的设计趋势：**让错误在编译期暴露，让语义写进类型系统。**

---

## 二、noexcept

### 1. noexcept 的本质

* 表示：**该函数不会抛出异常**
* 是一种 *编译期可检查的承诺*

```cpp
void f() noexcept;
```

---

### 2. noexcept 的两层含义

1. **语义层**：

   * 调用者可以放心调用
2. **优化层**：

   * 编译器可生成更激进的代码

---

### 3. noexcept 与异常

```cpp
void f() noexcept {
    throw 1; // ❌ 运行期直接 std::terminate
}
```

结论：

* noexcept 函数 **一旦抛异常就是致命错误**

---

### 4. noexcept 对 STL 的影响（重点）

```cpp
vector<T>
```

* `vector` 在扩容时：

  * 若 `T` 的 move 构造是 noexcept → **移动**
  * 否则 → **拷贝**

👉 直接影响性能

---

### 5. 条件 noexcept

```cpp
noexcept(noexcept(T(std::declval<T&&>())))
```

* 常见于模板
* 表达：**当且仅当内部操作不抛异常**

---

## 三、explicit

### 1. explicit 的本质

* 禁止 **隐式构造 / 隐式转换**

```cpp
struct A {
    explicit A(int x);
};
```

---

### 2. 没有 explicit 的风险

```cpp
struct A {
    A(int x);
};

A a = 10; // ❌ 隐式转换
```

问题：

* 易产生意外构造
* 隐藏 bug

---

### 3. explicit 的工程意义

* 提高接口清晰度
* 防止错误调用
* 对大型工程尤为重要

---

### 4. explicit 与单参数构造

准则：

> **除非你明确需要隐式转换，否则单参数构造函数一律 explicit**

---

## 四、noexcept + explicit 的设计哲学

* noexcept：**我保证不会失败**
* explicit：**你必须明确想这么做**

---

## 五、工程使用准则

* move 构造 / move 赋值 → noexcept
* 单参数构造函数 → explicit
* 公共接口慎用隐式语义

---

## 六、面试级总结

> noexcept 决定性能与异常语义，explicit 决定接口是否安全，二者是现代 C++ 接口设计的底线能力。
