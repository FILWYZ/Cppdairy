## 1. 为什么这是 C++ 后端的「生死线」？

在真实后端项目中：

* **90% 内存问题** 出现在「谁分配、谁释放」
* **线上内存泄漏** 多半源于 malloc / free 误用
* **C++ 与 C 最大分水岭** 就在 new/delete

> 👉 面试官通过这一题，判断你是：
>
> * 会写 C++ 语法的人
> * 还是理解 C++ 对象模型的工程师

---

## 2. 本质区别一句话总结

> **malloc/free 管的是“内存”**
> **new/delete 管的是“对象”**

---

## 3. new/delete vs malloc/free 全面对比

| 维度   | new / delete   | malloc / free |
| ---- | -------------- | ------------- |
| 语言层级 | C++            | C             |
| 返回类型 | 类型安全           | void*，需强转     |
| 构造函数 | ✅ 自动调用         | ❌ 不调用         |
| 析构函数 | ✅ 自动调用         | ❌ 不调用         |
| 内存大小 | 自动计算           | 手动传 size      |
| 异常处理 | 抛异常            | 返回 nullptr    |
| 可重载  | ✅ operator new | ❌             |

---

## 4. 对象 = 内存 + 行为（极重要）

```cpp
class User {
public:
    User() { cout << "Constructor" << endl; }
    ~User() { cout << "Destructor" << endl; }
};
```

* **malloc**：只给你一块“裸内存”
* **new**：
  1️⃣ 分配内存
  2️⃣ 调用构造函数
  3️⃣ 返回正确类型指针

---

## 5. 工程规范（你必须记住）

* new 必须配 delete
* malloc 必须配 free
* ❌ 绝对禁止混用

```cpp
User* u = (User*)malloc(sizeof(User));
// free(u);   // ❌ 析构函数不会调用
```

---

## 6. 后端工程师为什么不推荐 malloc？

### 原因 1：破坏 RAII

* C++ 核心思想：

  > 构造 = 资源获取
  > 析构 = 资源释放

malloc 无法参与 RAII

---

### 原因 2：异常不安全

```cpp
User* u = new User(); // 失败抛异常
User* v = (User*)malloc(sizeof(User)); // 失败返回 nullptr
```

后端服务中异常传播更安全

---

### 原因 3：不支持多态

```cpp
Base* p = new Derived(); // 正确
```

malloc 无法建立对象语义

---

## 7. 本 Day 与后端的真实关联

* 内存池
* 对象池
* 智能指针

👉 全部建立在 new/delete 语义之上

---
