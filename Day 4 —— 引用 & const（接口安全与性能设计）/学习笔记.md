## 一、Day 4 学习目标

> 从“会用语法”升级到：
>
> **写出来的函数接口，不容易被误用。**

在真实 C++ 后端项目中：

* const / 引用 ≠ 语法细节
* const / 引用 = **接口契约（Contract）**

---

## 二、const 在不同位置的含义（必会 + 面试高频）

### 1️⃣ const 修饰普通变量

```cpp
const int a = 10;
```

含义：

* a 只读
* 编译期保护

📌 工程意义：

* 明确“不会被修改”
* 减少误操作

---

### 2️⃣ const 修饰指针（三种情况，必须背到“条件反射”）

假设：

```cpp
int x = 10;
int y = 20;
```

#### （1）指向 const 的指针

```cpp
const int* p = &x;
```

* ❌ 不能通过 p 修改 x
* ✅ p 可以指向 y

使用场景：

* 只读访问

---

#### （2）const 指针

```cpp
int* const p = &x;
```

* ✅ 可以修改 x
* ❌ p 不能改指向

使用场景：

* 指针本身不能变（如成员指针）

---

#### （3）指向 const 的 const 指针

```cpp
const int* const p = &x;
```

* ❌ 不能改值
* ❌ 不能改指向

---

📌 **读法口诀（必背）**

> 从右向左读，看 const 修饰谁

---

### 3️⃣ const 修饰引用（最重要）

```cpp
void foo(const int& x);
```

含义：

* 函数承诺：不会修改参数

额外能力：

* 可以绑定普通变量
* 可以绑定 const 变量
* 可以绑定临时对象

📌 这是 **const T& 成为默认参数形式的根本原因**

---

## 三、引用 vs 指针（接口设计视角）

### 1️⃣ 指针接口的问题

```cpp
void process(User* u);
```

调用者的困惑：

* u 能不能为 nullptr？
* 是否会修改对象？
* 是否转移所有权？

👉 **语义模糊，容易误用**

---

### 2️⃣ 引用接口的优势

```cpp
void process(const User& u);
```

明确语义：

* 必须存在
* 只读
* 无所有权转移

👉 **接口即文档**

---

### 3️⃣ 工程级选择原则（非常重要）

| 场景    | 推荐方式                 |
| ----- | -------------------- |
| 必须存在  | `T&`                 |
| 只读    | `const T&`           |
| 可为空   | `T*`                 |
| 转移所有权 | `std::unique_ptr<T>` |

---

## 四、const 引用与性能

### 问题本质

```cpp
void f(Big b);              // 发生拷贝
void f(const Big& b);       // 零拷贝
```

结论：

* const 引用 = **零拷贝 + 语义安全**

👉 这是 C++ 高性能的核心设计之一

---
