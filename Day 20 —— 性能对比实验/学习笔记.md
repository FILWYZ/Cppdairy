本节目标：**用实验数据验证 STL 容器“理论复杂度 ≠ 实际性能”这一工程事实**，建立“以 cache / 内存模型为核心”的性能认知。

---

## 一、为什么要做性能对比实验？

### 1. 理论复杂度的局限

* O(n) / O(log n) 只描述增长趋势
* 忽略：

  * cache 命中率
  * 内存分布
  * 常数因子

> 在真实工程中，**内存访问模式往往比复杂度更重要**。

---

## 二、vector vs list

### 1. 理论对比

| 操作   | vector  | list |
| ---- | ------- | ---- |
| 随机访问 | O(1)    | 不支持  |
| 尾插   | O(1) 均摊 | O(1) |
| 中间插入 | O(n)    | O(1) |
| 遍历   | 极快      | 慢    |

---

### 2. 实验现象总结

* 遍历 / 查找：**vector 明显快于 list**
* 小规模插入：vector 依然更快
* list 的“O(1) 插入”在真实场景下常被 cache miss 抵消

---

### 3. 性能本质原因

* vector：

  * 连续内存
  * cache line 友好
* list：

  * 节点分散
  * 每次访问伴随指针跳转

---

## 三、map vs unordered_map

### 1. 理论对比

| 容器            | 底层  | 查找复杂度    |
| ------------- | --- | -------- |
| map           | 红黑树 | O(log n) |
| unordered_map | 哈希表 | O(1) 平均  |

---

### 2. 实验现象总结

* 随机查找：unordered_map 通常更快
* 小数据量：map 可能反而不慢
* 极端情况：unordered_map 可能退化为 O(n)

---

### 3. 性能影响因素

* 哈希函数质量
* bucket 数量
* 负载因子
* rehash 行为

---

## 四、工程结论

### 1. 不要迷信理论复杂度

* 连续内存优先
* 哈希并非万能

### 2. 性能选择原则

> **先 vector，再考虑 list；先 unordered_map，再评估 map 的有序需求。**

---

## 五、面试级总结

> STL 性能差异的核心不在算法复杂度，而在内存布局与 cache 行为。
