以下代码用于**复现实验现象**，建议在 `-O2` 下运行，并多次测试取平均值。

---

## 示例 1：vector vs list 遍历性能

```cpp
#include <vector>
#include <list>
#include <chrono>
#include <iostream>
using namespace std;

int main() {
    const int N = 1'000'000;
    vector<int> v(N, 1);
    list<int> l(N, 1);

    auto t1 = chrono::high_resolution_clock::now();
    long long sum1 = 0;
    for (int x : v) sum1 += x;
    auto t2 = chrono::high_resolution_clock::now();

    long long sum2 = 0;
    for (int x : l) sum2 += x;
    auto t3 = chrono::high_resolution_clock::now();

    cout << "vector: " << chrono::duration_cast<chrono::milliseconds>(t2 - t1).count() << "ms\n";
    cout << "list: " << chrono::duration_cast<chrono::milliseconds>(t3 - t2).count() << "ms\n";
}
```

---

## 示例 2：中间插入实验

```cpp
vector<int> v;
list<int> l;

for (int i = 0; i < 100000; ++i) {
    v.insert(v.begin(), i);
    l.push_front(i);
}
```

> 小规模下，vector 可能仍不慢。

---

## 示例 3：map vs unordered_map 查找性能

```cpp
#include <map>
#include <unordered_map>
#include <chrono>
#include <iostream>
using namespace std;

int main() {
    const int N = 500000;
    map<int,int> m;
    unordered_map<int,int> um;

    for (int i = 0; i < N; ++i) {
        m[i] = i;
        um[i] = i;
    }

    auto test = [&](auto& c) {
        auto t1 = chrono::high_resolution_clock::now();
        long long sum = 0;
        for (int i = 0; i < N; ++i) sum += c.find(i)->second;
        auto t2 = chrono::high_resolution_clock::now();
        return chrono::duration_cast<chrono::milliseconds>(t2 - t1).count();
    };

    cout << "map: " << test(m) << "ms\n";
    cout << "unordered_map: " << test(um) << "ms\n";
}
```

---

## 示例 4：unordered_map 退化演示（了解）

* 使用劣质 hash
* bucket 极少
* 查找性能接近 O(n)

---

## 实验建议

* 多次运行取平均
* 注意编译优化
* 不要在 Debug 模式下评估性能
