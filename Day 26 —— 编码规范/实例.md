通过实例体会 **“规范 vs 不规范” 在工程中的巨大差异**。

---

## 示例 1：规范的 header / source 分离

### my_class.h

```cpp
#pragma once

class MyClass {
public:
    MyClass(int value);
    int getValue() const;

private:
    int value_;
};
```

### my_class.cpp

```cpp
#include "my_class.h"

MyClass::MyClass(int value) : value_(value) {}

int MyClass::getValue() const {
    return value_;
}
```

---

## 示例 2：错误示例（实现写进头文件）

```cpp
// ❌ 不推荐
class Bad {
public:
    int f() { return 42; }
};
```

问题：

* 编译依赖膨胀
* 破坏接口与实现分离

---

## 示例 3：前向声明减少依赖

```cpp
// header
class Logger;

class Service {
    Logger* logger_;
};
```

---

## 示例 4：良好的命名

```cpp
class UserManager {
public:
    void addUser(const User& user);
};
```

---

## 示例 5：糟糕的命名

```cpp
class A {
public:
    void f(int x);
};
```

---

## 示例 6：布尔变量命名

```cpp
bool isEmpty;
bool hasError;
```

---

## 工程实践总结

* 头文件像 API 文档
* 命名决定可读性上限
