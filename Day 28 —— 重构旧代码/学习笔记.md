本节目标：**从“能跑的旧代码”升级为“安全、可维护、现代 C++ 风格的工程代码”**。

---

## 一、什么是“旧代码”？

在工程语境下，旧代码通常具备以下特征：

* 大量使用 `new / delete`
* 资源释放依赖人工约定
* 异常路径容易泄漏
* 所有权关系不清晰

👉 **旧 ≠ 写得早，而是设计思想停留在 C++98 时代。**

---

## 二、重构的第一原则

> **不改变外部行为，只改善内部结构**

* 功能不变
* 接口尽量稳定
* 风险可控

---

## 三、为什么优先引入智能指针？

### 1. 原始指针的根本问题

* 不表达所有权
* 易忘记释放
* 异常不安全

---

### 2. 智能指针解决的不是“内存”，而是“语义”

| 指针类型         | 表达语义  |
| ------------ | ----- |
| `unique_ptr` | 独占所有权 |
| `shared_ptr` | 共享所有权 |
| `weak_ptr`   | 非拥有引用 |

---

## 四、RAII 是什么？（核心思想）

**RAII（Resource Acquisition Is Initialization）**：

* 资源获取 = 对象构造
* 资源释放 = 对象析构

资源包括：

* 内存
* 文件
* 锁
* socket

---

## 五、RAII 的工程价值

* 异常安全（自动回收）
* 控制流简单
* 减少人为约定

> **RAII 是 C++ 区别于其他语言的核心竞争力之一。**

---

## 六、智能指针与 RAII 的关系

* 智能指针是 RAII 的具体实现
* 析构函数是资源回收的唯一入口

---

## 七、重构策略（推荐步骤）

1. 标注资源所有权
2. 用 `unique_ptr` 替换 `new/delete`
3. 最小化 `shared_ptr`
4. 封装资源为 RAII 类

---

## 八、常见误区

* 用 `shared_ptr` 代替设计
* 在 RAII 对象中暴露裸资源
* 智能指针嵌套智能指针

---

## 九、工程级总结

* 重构不是重写
* RAII 是稳定性的基石
* 智能指针是“语义工具”，不是“语法糖”

---

## 十、面试级总结

> 判断一个 C++ 工程是否现代，最直接的指标就是：是否系统性使用 RAII 和智能指针管理资源。
