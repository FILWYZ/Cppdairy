本文件通过 **可运行示例** 直观展示：

* 扩容行为
* 容量变化
* 迭代器失效

---

## 示例 1：观察扩容与 capacity 变化

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;

    size_t last_cap = v.capacity();
    for (int i = 0; i < 20; ++i) {
        v.push_back(i);
        if (v.capacity() != last_cap) {
            cout << "扩容: size=" << v.size()
                 << ", capacity=" << v.capacity() << '\n';
            last_cap = v.capacity();
        }
    }
}
```

**观察重点**：

* `capacity()` 不是每次都增长
* 每次增长通常成倍

---

## 示例 2：reserve 避免扩容

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v;
    v.reserve(100);

    cout << "初始 capacity=" << v.capacity() << '\n';

    for (int i = 0; i < 100; ++i)
        v.push_back(i);

    cout << "最终 capacity=" << v.capacity() << '\n';
}
```

**结论**：

* 没有发生任何 reallocation
* 适合已知数据规模的场景

---

## 示例 3：扩容导致迭代器失效（经典 UB）

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v;
    v.reserve(2);

    v.push_back(1);
    v.push_back(2);

    auto it = v.begin();

    v.push_back(3); // 触发扩容

    // 未定义行为
    cout << *it << endl;
}
```

⚠️ **说明**：

* `it` 指向旧内存
* 扩容后该内存已释放

---

## 示例 4：insert 导致部分迭代器失效

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4};

    auto it1 = v.begin();       // 指向 1
    auto it2 = v.begin() + 2;   // 指向 3

    v.insert(v.begin() + 1, 99);

    cout << *it1 << endl; // 仍然有效
    // cout << *it2 << endl; // 可能失效
}
```

---

## 示例 5：erase 的正确写法

```cpp
#include <vector>
using namespace std;

int main() {
    vector<int> v = {1,2,3,4,5};

    for (auto it = v.begin(); it != v.end(); ) {
        if (*it % 2 == 0)
            it = v.erase(it); // 返回下一个合法迭代器
        else
            ++it;
    }
}
```

---

## 工程实践建议

* 插入前 `reserve`
* 不长期保存 `vector` 迭代器
* 修改容器后 **重新获取迭代器**
