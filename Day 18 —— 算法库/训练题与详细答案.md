## 一、基础理解题

### 题 1：为什么 STL 算法不绑定具体容器？

#### 答案

* 基于迭代器区间设计
* 提高复用性与泛化能力
* 容器与算法解耦

---

### 题 2：`sort` 为什么不能用于 `list`？

#### 答案

* `sort` 需要随机访问迭代器
* list 仅支持双向迭代器

---

## 二、复杂度与特性题

### 题 3：`std::sort` 的最坏复杂度是多少？为什么？

#### 答案

* 最坏 `O(n log n)`
* 使用 Introsort，避免快排退化

---

### 题 4：`find` 和 `map::find` 的区别？

#### 答案

* 算法 `find`：线性 O(n)
* 成员 `map::find`：O(log n)

---

## 三、使用正确性判断

### 题 5：以下代码是否正确？

```cpp
vector<int> v = {1,2,3};
transform(v.begin(), v.end(), v.begin(), op);
```

#### 答案

* 正确
* 属于 in-place transform

---

### 题 6：以下代码问题在哪？

```cpp
vector<int> v = {1,2,3};
vector<int> out;
transform(v.begin(), v.end(), out.begin(), op);
```

#### 答案

* out 未分配空间
* 写入越界，UB

---

## 四、工程设计题

### 题 7：什么时候用 `transform` 优于 for 循环？

#### 答案

* 强调“区间到区间”的语义
* 可组合算法
* 代码表达更清晰

---

### 题 8：排序小规模数据为什么 vector+sort 很快？

#### 答案

* 连续内存
* cache 友好
* sort 常数因子小

---

## 五、面试总结题

### 题 9：一句话总结 sort / find / transform

#### 答案

> `sort` 做高效排序，`find` 做线性查找，`transform` 做区间映射，三者体现 STL 算法与容器解耦的核心设计思想。
