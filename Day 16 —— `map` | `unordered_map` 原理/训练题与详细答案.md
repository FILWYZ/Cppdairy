## 一、基础判断题

### 题 1：为什么 `map` 查找是 O(log n)？

#### 参考答案

* 底层是红黑树
* 高度被严格限制
* 查找路径长度 ≤ 树高

---

### 题 2：为什么 `unordered_map` 平均是 O(1)？

#### 参考答案

* 哈希函数直接定位 bucket
* bucket 内元素数量少
* 查找近似常数时间

---

## 二、复杂度退化题

### 题 3：`unordered_map` 在什么情况下会退化到 O(n)？

#### 参考答案

* 哈希函数质量差
* key 分布极度不均
* 大量元素进入同一 bucket

---

### 题 4：`map` 会不会出现类似退化？为什么？

#### 参考答案

* 不会
* 红黑树始终保持近似平衡
* 最坏复杂度仍为 `O(log n)`

---

## 三、工程判断题

### 题 5：以下代码是否安全？

```cpp
auto it = um.begin();
um[100] = 100;
use(*it);
```

#### 参考答案

* **不安全**
* 插入可能触发 rehash
* 所有迭代器可能失效

---

### 题 6：以下代码是否安全？

```cpp
auto it = m.begin();
m[100] = 100;
use(*it);
```

#### 参考答案

* **安全**
* `map` 插入不影响已有节点

---

## 四、选型设计题

### 题 7：什么场景必须使用 `map`？

#### 参考答案

* 需要有序遍历
* 需要区间查询
* 对最坏复杂度敏感

---

### 题 8：什么场景优先使用 `unordered_map`？

#### 参考答案

* 高频查找
* 无序要求
* 数据分布均匀

---

## 五、面试进阶题

### 题 9：为什么安全相关系统偏向使用 `map`？

#### 参考答案

* 避免哈希攻击
* 复杂度可预测
* 不存在性能退化

---

### 题 10：如何避免 `unordered_map` 的性能问题？

#### 参考答案

1. 自定义高质量 hash
2. 提前 `reserve`
3. 控制 load_factor

---

✅ **本题集覆盖：原理、退化、工程选型与面试场景**
