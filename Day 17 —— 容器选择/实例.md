## 示例 1：尾部频繁插入

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> log_buffer;
    for (int i = 0; i < 1000; ++i)
        log_buffer.push_back(i);
    cout << "Size=" << log_buffer.size() << endl;
}
```

**说明**：

* vector 尾部插入均摊 O(1)
* 顺序访问 cache 友好

---

## 示例 2：双端队列操作

```cpp
#include <deque>
#include <iostream>
using namespace std;

int main() {
    deque<int> dq;
    dq.push_back(1);
    dq.push_front(0);
    dq.pop_back();
    dq.pop_front();
}
```

**说明**：

* 两端操作 O(1)
* 中间插入仍为 O(n)

---

## 示例 3：中间插入稳定迭代器

```cpp
#include <list>
#include <iostream>
using namespace std;

int main() {
    list<int> lst = {1,2,3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 99);  // it 仍然有效
    for (int x : lst) cout << x << ' ';
}
```

**说明**：

* list 迭代器稳定
* 适合频繁中间插入/删除

---

## 示例 4：有序访问

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    map<int,string> config;
    config[3] = "C";
    config[1] = "A";
    config[2] = "B";

    for (auto& [k,v] : config)
        cout << k << ":" << v << ' ';
}
```

**说明**：

* map 保证 key 升序
* 区间查询方便

---

## 示例 5：高速查找

```cpp
#include <unordered_map>
#include <iostream>
using namespace std;

int main() {
    unordered_map<int,string> um;
    for (int i=0;i<100;i++) um[i] = to_string(i);
    cout << um[50] << endl;
}
```

**说明**：

* 平均 O(1) 查找
* 无序
* rehash 可能失效迭代器

---

## 示例 6：唯一元素集合

```cpp
#include <set>
#include <unordered_set>
#include <iostream>
using namespace std;

int main() {
    set<int> s;
    s.insert(3); s.insert(1); s.insert(3);
    for(int x:s) cout<<x<<' '; // 1 3

    unordered_set<int> us;
    us.insert(3); us.insert(1); us.insert(3);
}
```

**说明**：

* set 有序去重
* unordered_set 无序去重

---

## 工程实践建议

* 根据访问模式选容器
* 插入/删除频率决定 vector/deque/list
* 是否有序决定 map/set/unordered_map/unordered_set
* 考虑迭代器稳定性
* 对大规模频繁操作，提前 reserve 或考虑 list / deque
