本节目标：  
**把“Socket 阻塞 / 非阻塞、半连接队列 / 全连接队列”这些零散概念，整理为可面试表达、可工程定位的问题模型。**

---

## 一、为什么 Socket 细节在面试中权重很高？

很多 C++ 后端开发者：

* socket 写过
* accept / recv 用过
* 但一问到：
  * 阻塞和非阻塞的本质区别
  * 半连接队列满了会发生什么
就开始模糊

原因在于：

> **只会用 API，却没理解内核在“什么时候阻塞你”。**

---

## 二、理解 Socket 编程的核心视角

在讨论任何 socket 行为前，必须统一一个视角：

> **Socket 本质是“内核对象”，而不是普通函数调用。**

因此：

* 阻塞 / 非阻塞
* 队列是否已满

决定的不是你写没写代码，而是：

> **内核是否“有条件立刻满足你的请求”。**

---

## 三、阻塞 Socket 的本质行为

阻塞 socket 的核心特征只有一句话：

> **条件不满足时，线程会被内核挂起。**

常见阻塞点包括：

* accept：没有新连接
* recv：没有数据
* send：发送缓冲区已满

工程影响：

* 线程被占用
* 并发能力受限
* 需要配合多线程或多进程模型

---

## 四、非阻塞 Socket 的设计初衷

非阻塞 socket 的核心目标是：

> **不让线程被“无限期等待”绑定住。**

行为特征：

* 系统调用立即返回
* 条件不满足时返回错误（如 EAGAIN / EWOULDBLOCK）
* 需要程序主动管理“何时再试”

因此：

> **非阻塞 socket 必然要配合 IO 多路复用使用。**

---

## 五、什么是半连接队列？

半连接队列（SYN Queue）用于存放：

* 已收到 SYN
* 但 **三次握手尚未完成**
的连接请求

此时连接状态为：

* SYN_RECV

核心认知：

> **半连接队列用于“防御”和“缓冲”，不是最终可用连接。**

---

## 六、什么是全连接队列？

全连接队列（Accept Queue）用于存放：

* 三次握手已完成
* 等待应用层 accept 的连接

此时：

* TCP 连接已经建立
* 但应用程序尚未取走

一句话总结：

> **全连接队列中的连接，已经是“可用资源”。**

---

## 七、两个队列的工程意义

| 队列 | 所处阶段 | 面向对象 |
|----|----|----|
| 半连接队列 | 握手中 | TCP 协议栈 |
| 全连接队列 | 已完成 | 应用层 |

---

## 八、本节总结

> Socket 编程的关键，不在 API 本身，  
> 而在于：**你是否清楚自己在和“内核状态机”打交道。**
