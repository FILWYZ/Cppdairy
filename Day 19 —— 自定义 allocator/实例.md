以下示例用于**理解 allocator 的结构与使用方式**，而非追求工程级完整实现。

---

## 示例 1：自定义最小 allocator 框架

```cpp
#include <cstddef>
#include <memory>

template<typename T>
struct SimpleAllocator {
    using value_type = T;

    SimpleAllocator() = default;

    template<typename U>
    SimpleAllocator(const SimpleAllocator<U>&) {}

    T* allocate(std::size_t n) {
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t) {
        ::operator delete(p);
    }
};
```

---

## 示例 2：在 vector 中使用自定义 allocator

```cpp
#include <vector>

std::vector<int, SimpleAllocator<int>> v;
v.push_back(1);
v.push_back(2);
```

> vector 的所有内存申请都会走 `SimpleAllocator`。

---

## 示例 3：allocator 不负责构造对象

```cpp
T* p = alloc.allocate(1);
// 此时只是原始内存

std::allocator_traits<Alloc>::construct(alloc, p, value);
```

* allocate：分配内存
* construct：在内存上构造对象

---

## 示例 4：错误认知示例

❌ allocator == 内存池（错误）

* allocator 只是接口
* 是否是池化取决于实现

---

## 示例 5：工程级 allocator 通常包含

* 内存池
* 对齐处理
* 统计信息
* 线程安全策略

> 这些都远超面试与基础 STL 学习范围。

---

## 实践建议

* 不要在业务代码中盲目自定义 allocator
* allocator 适合被封装在基础设施层
